{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structures and Algorithms practice problems \u00b6 Getting Started \u00b6 This website contains collection of data structures and algorithms problems and suggested solutions for these problems. Contributors \u00b6 Please don't hesitate to give me your feedback if any adjustment is needed with the sorted solutions. You can simply press the \"Pencil icon\" in the upper right corner to edit the contents or simply open an issue in my repository . More Informations \u00b6 For more informations please visit my GitHub site .","title":"Home"},{"location":"#data-structures-and-algorithms-practice-problems","text":"","title":"Data Structures and Algorithms practice problems"},{"location":"#getting-started","text":"This website contains collection of data structures and algorithms problems and suggested solutions for these problems.","title":"Getting Started"},{"location":"#contributors","text":"Please don't hesitate to give me your feedback if any adjustment is needed with the sorted solutions. You can simply press the \"Pencil icon\" in the upper right corner to edit the contents or simply open an issue in my repository .","title":"Contributors"},{"location":"#more-informations","text":"For more informations please visit my GitHub site .","title":"More Informations"},{"location":"color/","text":"Primary colors \u00b6 Default: Teal Click on a tile to change the primary color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; }) })","title":"Color"},{"location":"color/#primary-colors","text":"Default: Teal Click on a tile to change the primary color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; }) })","title":"Primary colors"},{"location":"Graph/1/","text":"Question Let an undirected simple graph $G(V, E)$ be given with $n$ nodes and $m$ edges. The edges have an associated positive weight: $w(x,y) > 0$ for the edge between node $x$ and $y$. This questions concerns itself with a variation of shortest path. For the purpose of question, if a particular path from $x$ to $y$ is $x \u2192 a \u2192 b \u2192 c \u2192 y$, then we refer to $a,b,$ and $c$ as lay-over nodes for that particular path. Now your question: Design an efficient algorithm that finds the shortest weighted distance between two given nodes $s$ and $t$, with the additional requirement: there is a cost associated with lay-over nodes. You can visit up to two lay-over nodes for free,but every additional lay-over will incur a fee. Let $c(k)$ the cost associated with the $k$ node on the path. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Dijkstra ( G , s , t ): Q = \u2205 # create priority queue dis [ s ] = 0 for each vertex v in G : if v != s dis [ v ] = \u221e \u03c0 ( v ) = nil hop [ v ] = 0 c [ v ] = 0 Q . enqueue ( dis [ v ]) # set all vertices in Q While Q not empty : u \u2190 extractMin ( Q ) for each neighbor v of u : hop [ v ] = hop [ u ] + 1 if hop [ v ] >= 3 # check if lay-over/hops more or equal to 3 c [ v ] = c [ v ] + hop [ v ] alt = d [ u ] + w ( v , u ) + c [ v ] if d [ v ] > alt d [ v ] = alt \u03c0 ( v ) = u Q . decrease_priority ( v , alt ) # retrieve the path from s to t Stack S = \u2205 # create a stack Push ( S , t ) v \u2190 Top ( S ) while \u03c0 ( v ) != nil Push ( S , \u03c0 ( v )) v = \u03c0 ( v ) return S # The path is stored in the stack S from top to bottom. End","title":"Shortest Path with Limited Hops"},{"location":"Graph/2/","text":"Question Suppose $T$ is a minimum spanning tree (MST) of graph $G(V, E)$. An edge $(u, v) \u2208 E$ is not in $T, (u, v) \u2209 T$. Now, the weight of $(u, v)$ reduces to $w(u, v)$ so that T may be no longer an MST. Please design an $O(n)$ algorithm that modifies $T$ to obtain a new MST for graph $G$ with this change, where $n = |V|$. You need to prove its correctness The idea is to add the reduced edge $(u,v)$ to the Tree $T$. Now, we have a cycle, and $T$ are no longer an MST. We need to modify $T$ to obtain a new MST by applying BFS on $T$ where node $u$ is the source node. While we traverse the Tree $T$ we keep track of largest edge and remove it from $T$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 T = T \u222a { e ( u , v )} # add the reduced edge to the Tree BFS ( T , s ): e ( x , y ) = nil largest = 0 Q = \u2205 # create a queue Enqueue ( Q , s ) while Q not empty : u \u2190 Dequeue ( Q ) for each neighbor v of u and not in Q : if largest < w ( v , u ) # keep track of the largest edge largest = w ( v , u ) e ( x , y ) = e ( v , u ) Enqueue ( Q , v ) T = T - { e ( x , y )} # remove the largest edge from the Tree End","title":"Minimum Spanning Tree (MST)"},{"location":"Graph/3/","text":"Question An independent set of a graph $G = (V, E)$ is a subset $V\u2019 \u2286 V$ of vertices such that each edge in $E$ is incident on at most one vertex in $V\u2019$. The independent-set problem is to find a maximum-size independent set in $G$. This is a difficult NP-complete problem for general graph $G$. However, it is not difficult if $G$ is a tree. Let $T = (V, E)$ be a tree, where $V$ is the vertex set and E is the edge set. Please design an $O(n)$ algorithm to find a maximum-size independent set (MIS) in $T$, where $n = |V|$. We assume $T$ is represented by an adjacency list. You need to show the pseudo code for your algorithm. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 for each vertex v in T : children [ v ] = 0 \u03c0 ( v ) = nil isParent [ v ] = False visited [ v ] = False Q = \u2205 # create a queue topological - Sort ( T , u ): visited [ u ] = True for each neighbor v of u : if visited [ v ] = False : children [ u ] += 1 \u03c0 ( v ) = u topological - Sort ( T , v ): Enqueue ( Q , u ) End unweighted - MIS ( Q ): while Q not empty : v \u2190 Dequeue ( Q ) MIS = MIS U { v } if \u03c0 ( v ) = nil # we reach the root return MIS children [ \u03c0 ( v )] -= 1 # decrese No. of children of v's parent if children [ \u03c0 ( v )] >= 1 isParent [ \u03c0 ( v )] = True else u \u2190 Dequeue ( Q ) if \u03c0 ( u ) != nil # because root don't have parent children [ \u03c0 ( u )] -= 1 # to decrese No. of their children if isParent [ \u03c0 ( u )] = True and children [ \u03c0 ( u )] = 0 u \u2190 Dequeue ( Q ) children [ \u03c0 ( u )] -= 1 return MIS End","title":"Maximum Unweighted Independent Set in Tree"},{"location":"Graph/4/","text":"Question Given a weighted (undirected) graph $G(V, E)$, the weight of an edge is called the width of the edge. The width of a path is defined to be the smallest weight among all edges on the path. (An edge with the smallest weight is called the bottle neck edge.) For example, in the following graph, the path $ $ has width 7. A path $P(u, v)$ is called the widest if the width of the path is the largest among all paths from $u$ to $v$. For example, in the above figure, the widest path between vertex a and vertex $g$ is $ $ whose width is 8. Please modify Dijkstra\u2019s algorithm to compute the widest path from a given vertex $s \u2208 V$ to every other vertex. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Dijkstra_Widest_path ( G , s , t ): Q = \u2205 # create priority queue width [ s ] = \u221e for each vertex v in G : if v != s width [ v ] : = - \u221e ; \u03c0 ( v ) = nil Q . enqueue ( width [ v ]) # set all vertices in Q While Q not empty : u \u2190 extractMax ( Q ) for each neighbor v of u : alt = max ( width [ v ], min ( width [ u ], w ( u , v ))) if alt > width [ v ]: width [ v ] = alt ; \u03c0 ( v ) : = u ; Q . increase - key ( v , alt ) # updating a key within a max-heap # retrieve the path from s to t Stack S = \u2205 # create a stack Push ( S , t ) v \u2190 Top ( S ) while \u03c0 ( v ) != nil Push ( S , \u03c0 ( v )) v = \u03c0 ( v ) return S # The path is stored in the stack S from top to bottom. End","title":"4"},{"location":"Tree/1/","text":"Question Let $T(V, E)$ be a weighted tree rooted at node $r \u2208 V$. We define $M(r, v)$ to be the weight of the largest weighted edge on the path from $r$ to $v$. The following figure shows an example. $M(r, a) = 5, M(r, b) = 9, M(r, c) = 5, M(r, d) = 5, M(r, e) = 11, M(r, f) = -3, M(r, g) = -3$ $M(r, h) = 9,M(r, i) = 8, M(r, j) = 10, M(r, k) = 8, M(r, l) = 7$. Please design an O(n) algorithm to compute $M(r, v)$ for each and every node $v (\u2260 r)$ in $V$. We assume, for each node $u$, its father $\u03c0(u)$ is known $(\u03c0(r) = r)$, and its children are organized by a linked list. You can simply call \u201cu\u2019s next son\u201d to get its next son or first son. \u201cu\u2019s next son = $nil$\u201d means you have looked all its sons or it is a leaf. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 M ( r , r ) = - \u221e \u03c0 ( r ) = r for each r \u2019 s next son : Tree - Traversal ( T , r , r . next ) Tree - Traversal ( T , r , v ) if v = nil : return nil else : M ( r , v ) \u2190 MAX ( w ( \u03c0 ( v ), v ) , M ( r , \u03c0 ( v ))) for each v \u2019 s next son : Tree - Traversal ( T , r , v . next ) End The Time Complexity is $O(n)$, since we visite all the node of tree once. alternative solution: We remove the root's loop and assume that $w(r,r) = - \u221e$. 1 2 3 4 5 6 7 8 9 10 11 12 M ( r , r ) = - \u221e w ( r , r ) = - \u221e \u03c0 ( r ) = r v = r # start traversal from the root r Tree - Traversal ( T , r , v ) if v = nil : return nil else : M ( r , v ) \u2190 MAX ( w ( \u03c0 ( v ), v ) , M ( r , \u03c0 ( v ))) For each v \u2019 s next son : Tree - Traversal ( T , r , v . next ) End","title":"Tree Traversal"},{"location":"Tree/2/","text":"Question A binary search tree is a full binary tree in which every internal node holds a number. Moreover, any number in a node $x$ is larger than any number in the left subtree of $x$ and smaller than any number in its right subtree. Any leaf contains no data and holds a special symbol nil. An example is given below. Any node x has 4 fields, $key(x), father(x), left(x),$ and $right(x)$, where $key(x)$ is the value of the number stored in $x$. The other three are pointers to its father node, left child and right child, respectively. The father of the root is nil. Obviously, if we do pre-order , we will get a sorted (not including leaves). A node $y$ is called the successor of $x$ if $key(y)$ is the next number after $key(x)$ in the sorted sequence. For example, in the following example, 13 is the successor of 10. Please write a program or a pseudo code that finds the successor for a given node $x$. 1 2 3 4 5 6 7 8 9 10 11 12 13 Get - Successor ( T , root , x ) if ( left ( x ) != nil ) # case 1: node has left child return left ( x ) else # case 2: No left or right child. Then we travel up. while ( father ( x ) != nil & right ( father ( x )) == x ) x \u2190 father ( x ) father ( x ) \u2190 father ( parent ( x )) if ( father ( x ) = nil ) # we reach the root. No result found return nil return right ( father ( x )) End","title":"Pre-order Successor of a Node"}]}