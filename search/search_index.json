{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solutions to Introduction to Algorithms Third Edition Getting Started This website contains nearly complete solutions to the bible textbook - Introduction to Algorithms Third Edition published by Thomas H. Cormen , Charles E. Leiserson , Ronald L. Rivest and Clifford Stein . Hope to reorganize solutions to help more people and myself study algorithms. By using Markdown (.md) files, it's much more readable on portable devices now. \"Many a little makes a mickle.\" Contributors Thanks to: the Instructor's Manual by Thomas H. Cormen , @skanev , @CyberZHG , @yinyanghu , @ajl213, etc. Special thanks to @JeffreyCA , who fixed MathJax rendering on iOS Safari in #26 . Please don't hesitate to give me your feedback if any adjustment is needed with the sorted solutions. You can simply press the \"Pencil icon\" in the upper right corner to edit the contents or simply open an issue in my repository . Working on following exercises 18.2-1 , 19.2-1 . I will continue to complete VII Selected Topics. How I generate this website I use the static site generator MkDocs and the beautiful theme Material for MkDocs to build this website! Since KaTeX is now supporting more functions and is much faster than MathJax , I've updated all math equations from MathJax to KaTeX . I also add overflow-x: auto to prevent the overflow issue on mobile devices, so you can scroll horizontally in the math display equations. More Informations For more informations please visit my GitHub site . Updated to this new site on April 13, 2018 at 04:48 (GMT+8) .","title":"Preface"},{"location":"#solutions-to-introduction-to-algorithms-third-edition","text":"","title":"Solutions to Introduction to Algorithms Third Edition"},{"location":"#getting-started","text":"This website contains nearly complete solutions to the bible textbook - Introduction to Algorithms Third Edition published by Thomas H. Cormen , Charles E. Leiserson , Ronald L. Rivest and Clifford Stein . Hope to reorganize solutions to help more people and myself study algorithms. By using Markdown (.md) files, it's much more readable on portable devices now. \"Many a little makes a mickle.\"","title":"Getting Started"},{"location":"#contributors","text":"Thanks to: the Instructor's Manual by Thomas H. Cormen , @skanev , @CyberZHG , @yinyanghu , @ajl213, etc. Special thanks to @JeffreyCA , who fixed MathJax rendering on iOS Safari in #26 . Please don't hesitate to give me your feedback if any adjustment is needed with the sorted solutions. You can simply press the \"Pencil icon\" in the upper right corner to edit the contents or simply open an issue in my repository .","title":"Contributors"},{"location":"#working-on-following-exercises","text":"18.2-1 , 19.2-1 . I will continue to complete VII Selected Topics.","title":"Working on following exercises"},{"location":"#how-i-generate-this-website","text":"I use the static site generator MkDocs and the beautiful theme Material for MkDocs to build this website! Since KaTeX is now supporting more functions and is much faster than MathJax , I've updated all math equations from MathJax to KaTeX . I also add overflow-x: auto to prevent the overflow issue on mobile devices, so you can scroll horizontally in the math display equations.","title":"How I generate this website"},{"location":"#more-informations","text":"For more informations please visit my GitHub site . Updated to this new site on April 13, 2018 at 04:48 (GMT+8) .","title":"More Informations"},{"location":"color/","text":"Primary colors Default: Teal Click on a tile to change the primary color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; }) })","title":"Color"},{"location":"color/#primary-colors","text":"Default: Teal Click on a tile to change the primary color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; }) })","title":"Primary colors"},{"location":"Graph/test12/","text":"1.1 Let $T(V, E)$ be a weighted tree rooted at node $r \u2208 V$. We define M(r, v) to be the weight of the largest weighted edge on the path from $r$ to $v$. The following figure shows an example. M(r, a) = 5, M(r, b) = 9, M(r, c) = 5, M(r, d) = 5, M(r, e) = 11, M(r, f) = -3, M(r, g) = -3, M(r, h) = 9, M(r, i) = 8, M(r, j) = 10, M(r, k) = 8, M(r, l) = 7. Please design an O(n) algorithm to compute M(r, v) for each and every node v (\u2260 r) in V. We assume, for each node u, its father \u03c0(u) is known (\u03c0(r) = r), and its children are organized by a linked list. You can simply call \u201cu\u2019s next son\u201d to get its next son or first son. \u201cu\u2019s next son = nil\u201d means you have looked all its sons or it is a leaf. v = r.next M(r,r) \u2190 - \u221e w(r,r) = - \u221e \u03c0(r) = r Tree-Traversal(T,r,v) 1: if v = nil : 2: return nil 3: else 4: M(r,v) \u2190 MAX ( w(\u03c0(v),v) ,M(r,\u03c0(v))) 5: For each v\u2019s next son: 6: Tree-Traversal( T, r, v.next ) End","title":"Test12"},{"location":"Graph/test12/#11","text":"Let $T(V, E)$ be a weighted tree rooted at node $r \u2208 V$. We define M(r, v) to be the weight of the largest weighted edge on the path from $r$ to $v$. The following figure shows an example. M(r, a) = 5, M(r, b) = 9, M(r, c) = 5, M(r, d) = 5, M(r, e) = 11, M(r, f) = -3, M(r, g) = -3, M(r, h) = 9, M(r, i) = 8, M(r, j) = 10, M(r, k) = 8, M(r, l) = 7. Please design an O(n) algorithm to compute M(r, v) for each and every node v (\u2260 r) in V. We assume, for each node u, its father \u03c0(u) is known (\u03c0(r) = r), and its children are organized by a linked list. You can simply call \u201cu\u2019s next son\u201d to get its next son or first son. \u201cu\u2019s next son = nil\u201d means you have looked all its sons or it is a leaf. v = r.next M(r,r) \u2190 - \u221e w(r,r) = - \u221e \u03c0(r) = r Tree-Traversal(T,r,v) 1: if v = nil : 2: return nil 3: else 4: M(r,v) \u2190 MAX ( w(\u03c0(v),v) ,M(r,\u03c0(v))) 5: For each v\u2019s next son: 6: Tree-Traversal( T, r, v.next ) End","title":"1.1"},{"location":"Tree/1/","text":"1.1 Let $T(V, E)$ be a weighted tree rooted at node $r \u2208 V$. We define M(r, v) to be the weight of the largest weighted edge on the path from $r$ to $v$. The following figure shows an example. $M(r, a) = 5, M(r, b) = 9, M(r, c) = 5, M(r, d) = 5, M(r, e) = 11, M(r, f) = -3, M(r, g) = -3, M(r, h) = 9, M(r, i) = 8, M(r, j) = 10, M(r, k) = 8, M(r, l) = 7$. Please design an O(n) algorithm to compute M(r, v) for each and every node v (\u2260 r) in V. We assume, for each node u, its father \u03c0(u) is known (\u03c0(r) = r), and its children are organized by a linked list. You can simply call \u201cu\u2019s next son\u201d to get its next son or first son. \u201cu\u2019s next son = nil\u201d means you have looked all its sons or it is a leaf. v = r.next M(r,r) = - \u221e w(r,r) = - \u221e \u03c0(r) = r Tree-Traversal(T,r,v) 1: if v = nil : 2: return nil 3: else : 4: M(r,v) \u2190 MAX ( w(\u03c0(v),v) ,M(r,\u03c0(v))) 5: For each v\u2019s next son: 6: Tree-Traversal( T, r, v.next ) End","title":"P1"},{"location":"Tree/1/#11","text":"Let $T(V, E)$ be a weighted tree rooted at node $r \u2208 V$. We define M(r, v) to be the weight of the largest weighted edge on the path from $r$ to $v$. The following figure shows an example. $M(r, a) = 5, M(r, b) = 9, M(r, c) = 5, M(r, d) = 5, M(r, e) = 11, M(r, f) = -3, M(r, g) = -3, M(r, h) = 9, M(r, i) = 8, M(r, j) = 10, M(r, k) = 8, M(r, l) = 7$. Please design an O(n) algorithm to compute M(r, v) for each and every node v (\u2260 r) in V. We assume, for each node u, its father \u03c0(u) is known (\u03c0(r) = r), and its children are organized by a linked list. You can simply call \u201cu\u2019s next son\u201d to get its next son or first son. \u201cu\u2019s next son = nil\u201d means you have looked all its sons or it is a leaf. v = r.next M(r,r) = - \u221e w(r,r) = - \u221e \u03c0(r) = r Tree-Traversal(T,r,v) 1: if v = nil : 2: return nil 3: else : 4: M(r,v) \u2190 MAX ( w(\u03c0(v),v) ,M(r,\u03c0(v))) 5: For each v\u2019s next son: 6: Tree-Traversal( T, r, v.next ) End","title":"1.1"},{"location":"Tree/2/","text":"!!! question A binary search tree is a full binary tree in which every internal node holds a number. Moreover, any number in a node x is larger than any number in the left subtree of $x$ and smaller than any number in its right subtree. Any leaf contains no data and holds a special symbol nil. An example is given below. Any node $x$ has 4 fields, $key(x)$, $father(x)$, $left(x)$, and $right(x)$, where $key(x)$ is the value of the number stored in $x$. The other three are pointers to its father node, left child and right child, respectively. The father of the root is nil. Obviously, if we do pre-order traversal, we will get a sorted sequence (not including leaves). A node y is called the successor of $x$ if $key(y)$ is the next number after $key(x)$ in the sorted sequence.For example, in the following example, 7 is the successor of 10. Please write a program or a pseudo code that finds the $successor$ for a given node $x$. Get-Successor(T, root, x) 1: IF (left(x) != nil) # case 1: node has left child 2: Return left(x) 3: 4: ELSE # case 2: No left or right child. Then we travel up. 5: WHILE (father(x) != nil & right(father(x)) == x) 6: x \u2190 father(x) 7: father(x) \u2190 father(parent(x)) 8: IF (father(x) = nil) # we reach the root. No result found 9: Return nil 10: 11: Return right(father(x)) End","title":"P2"}]}