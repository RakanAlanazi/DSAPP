{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structures and Algorithms practice problems \u00b6 Getting Started \u00b6 This website contains collection of data structures and algorithms problems and suggested solutions for these problems. Contributors \u00b6 Please don't hesitate to give me your feedback if any adjustment is needed with the sorted solutions. You can simply press the \"Pencil icon\" in the upper right corner to edit the contents or simply open an issue in my repository . More Informations \u00b6 For more informations please visit my GitHub site .","title":"Home"},{"location":"#data-structures-and-algorithms-practice-problems","text":"","title":"Data Structures and Algorithms practice problems"},{"location":"#getting-started","text":"This website contains collection of data structures and algorithms problems and suggested solutions for these problems.","title":"Getting Started"},{"location":"#contributors","text":"Please don't hesitate to give me your feedback if any adjustment is needed with the sorted solutions. You can simply press the \"Pencil icon\" in the upper right corner to edit the contents or simply open an issue in my repository .","title":"Contributors"},{"location":"#more-informations","text":"For more informations please visit my GitHub site .","title":"More Informations"},{"location":"color/","text":"Primary colors \u00b6 Default: Teal Click on a tile to change the primary color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; }) })","title":"Color"},{"location":"color/#primary-colors","text":"Default: Teal Click on a tile to change the primary color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; }) })","title":"Primary colors"},{"location":"Graph/1/","text":"Question Let an undirected simple graph $G(V, E)$ be given with $n$ nodes and $m$ edges. The edges have an associated positive weight: $w(x,y) > 0$ for the edge between node $x$ and $y$. This questions concerns itself with a variation of shortest path. For the purpose of question, if a particular path from $x$ to $y$ is $x \u2192 a \u2192 b \u2192 c \u2192 y$, then we refer to $a,b,$ and $c$ as lay-over nodes for that particular path. Now your question: Design an efficient algorithm that finds the shortest weighted distance between two given nodes $s$ and $t$, with the additional requirement: there is a cost associated with lay-over nodes. You can visit up to two lay-over nodes for free,but every additional lay-over will incur a fee. Let $c(k)$ the cost associated with the $k$ node on the path. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Dijkstra ( G , s , t ): for each vertex v in G : dis [ v ] = \u221e \u03c0 ( v ) = nil hop [ v ] = 0 c [ v ] = 0 dis [ s ] = 0 Q = \u2205 While Q not empty : u \u2190 extractMin ( Q ) for each neighbor v of u : hop [ v ] = hop [ u ] + 1 if hop [ v ] >= 3 c [ v ] = c [ v ] + hop [ v ] if d [ v ] > d [ u ] + w ( v , u ) + c [ v ] d [ v ] = d [ u ] + w ( v , u ) + c [ v ] \u03c0 ( v ) = u enqueue ( Q , v ) Stack S = \u2205 # Create a stack Push ( S , t ) v \u2190 Top ( S ) while \u03c0 ( v ) != nil Push ( S , \u03c0 ( v )) v = \u03c0 ( v ) return S # The path is stored in the stack S from top to bottom. End","title":"Shortest Path With Limited Hops"},{"location":"Tree/1/","text":"Question Let $T(V, E)$ be a weighted tree rooted at node $r \u2208 V$. We define $M(r, v)$ to be the weight of the largest weighted edge on the path from $r$ to $v$. The following figure shows an example. $M(r, a) = 5, M(r, b) = 9, M(r, c) = 5, M(r, d) = 5, M(r, e) = 11, M(r, f) = -3, M(r, g) = -3$ $M(r, h) = 9,M(r, i) = 8, M(r, j) = 10, M(r, k) = 8, M(r, l) = 7$. Please design an O(n) algorithm to compute $M(r, v)$ for each and every node $v (\u2260 r)$ in $V$. We assume, for each node $u$, its father $\u03c0(u)$ is known $(\u03c0(r) = r)$, and its children are organized by a linked list. You can simply call \u201cu\u2019s next son\u201d to get its next son or first son. \u201cu\u2019s next son = $nil$\u201d means you have looked all its sons or it is a leaf. 1 2 3 4 5 6 7 8 9 10 11 12 M ( r , r ) = - \u221e w ( r , r ) = - \u221e \u03c0 ( r ) = r v = r # start traversal from the root r Tree - Traversal ( T , r , v ) if v = nil : return nil else : M ( r , v ) \u2190 MAX ( w ( \u03c0 ( v ), v ) , M ( r , \u03c0 ( v ))) For each v \u2019 s next son : Tree - Traversal ( T , r , v . next ) End","title":"Tree Traversal"},{"location":"Tree/2/","text":"Question A binary search tree is a full binary tree in which every internal node holds a number. Moreover, any number in a node $x$ is larger than any number in the left subtree of $x$ and smaller than any number in its right subtree. Any leaf contains no data and holds a special symbol nil. An example is given below. Any node x has 4 fields, $key(x), father(x), left(x),$ and $right(x)$, where $key(x)$ is the value of the number stored in $x$. The other three are pointers to its father node, left child and right child, respectively. The father of the root is nil. Obviously, if we do pre-order , we will get a sorted (not including leaves). A node $y$ is called the successor of $x$ if $key(y)$ is the next number after $key(x)$ in the sorted sequence. For example, in the following example, 13 is the successor of 10. Please write a program or a pseudo code that finds the successor for a given node $x$. 1 2 3 4 5 6 7 8 9 10 11 12 13 Get - Successor ( T , root , x ) if ( left ( x ) != nil ) # case 1: node has left child return left ( x ) else # case 2: No left or right child. Then we travel up. while ( father ( x ) != nil & right ( father ( x )) == x ) x \u2190 father ( x ) father ( x ) \u2190 father ( parent ( x )) if ( father ( x ) = nil ) # we reach the root. No result found return nil return right ( father ( x )) End","title":"Pre-order Successor of a Node"}]}